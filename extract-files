#!/usr/bin/env python
#
# Copyright (C) 2012 The CyanogenMod Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime, inspect, os, subprocess

def yield_lines(files, basedir=None):
    for f in files:
        if basedir is not None:
            f = os.path.join(basedir, f)
        if os.path.isdir(f):
            for rootdir, subdirs, subfiles in os.walk(f):
                for s in yield_lines(subfiles, rootdir):
                    yield s
        else:
            for s in open(f, 'r'):
                s = s.strip()
                if s and not s.startswith('#'):
                    yield s

class VendorCreator:

    def __init__(self):
        self.cm_tree, self.filename = os.path.split(
                os.path.realpath(inspect.stack()[1][1])
        )
        self.cm_tree, self.device = os.path.split(self.cm_tree)
        self.cm_tree, self.manufacturer = os.path.split(self.cm_tree)
        self.cm_tree = os.path.dirname(self.cm_tree)
        self.device_tree = os.path.join('device', self.manufacturer, self.device)
        self.vendor_tree = os.path.join('vendor', self.manufacturer, self.device)
        self.prop_dir = os.path.join(self.vendor_tree, 'props')
        self.srcs = set(); self.inst_maps = set(); self.boilerplate = \
'''#
# Copyright (C) %s The CyanogenMod Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file is generated by %s

'''%(datetime.datetime.now().year, \
        os.path.join(self.device_tree, self.filename))

    def _blobs_mkfile_writer(self):
        self.blobs_mkfile = \
                os.path.join(self.vendor_tree, 'blobs.mk')
        blobs_mkfile = open(self._realpath(self.blobs_mkfile), 'w')
        blobs_mkfile.write(self.boilerplate)
        blobs_mkfile.write('PRODUCT_COPY_FILES += \\\n')
        for src, path in self.inst_maps:
            blobs_mkfile.write('    ')
            blobs_mkfile.write(os.path.join(self.prop_dir, src))
            blobs_mkfile.write(':')
            blobs_mkfile.write(path)
            blobs_mkfile.write(' \\\n')
        blobs_mkfile.write('\n')
        blobs_mkfile.close()

    def _base_mkfile_writer(self):
        self.base_mkfile = \
                os.path.join(self.vendor_tree, 'vendor.mk')
        base_mkfile = open(self._realpath(self.base_mkfile), 'w')
        base_mkfile.write(self.boilerplate)
        base_mkfile.write('$(call inherit-product, ')
        base_mkfile.write(self.blobs_mkfile)
        base_mkfile.write(')')
        base_mkfile.write('\n')
        base_mkfile.close()

    def _add_prop(self, args):
        src = args.pop(0)
        inc_src = not (src and args)
        while not src:
            src = args.pop(0)
        cmd = ['adb', 'pull', src]
        cmd.append(os.path.join(self.cm_tree, self.prop_dir, src))
        out_dir = os.path.dirname(cmd[-1])
        if not os.path.isdir(out_dir):
            os.makedirs(out_dir)
        print(src)
        subprocess.call(cmd)
        if inc_src:
            self.inst_maps.add((src, src))
        for arg in args:
            self.inst_maps.add((src, arg))

    def _realpath(self, path):
        return os.path.realpath(os.path.join(self.cm_tree, path))

    def add(self, filename):
        self.srcs.add(
                self._realpath(os.path.join(self.device_tree, filename))
        )

    def generate(self):
        for s in yield_lines(self.srcs):
            self._add_prop(s.split(':'))
        self._blobs_mkfile_writer()
        self._base_mkfile_writer()

vc0 = VendorCreator()
vc0.add('props_lists')

if __name__ == '__main__':
    vc0.generate()
